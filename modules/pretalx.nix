{
  config,
  lib,
  pkgs,
  ngipkgs,
  ...
}:
with builtins;
with lib; let
  cfg = config.services.pretalx;
  gunicorn = pkgs.python3Packages.gunicorn;
  libDir = "/var/lib/pretalx";

  init = pkgs.writeScriptBin "expect-pretalx-init" ''
    #! ${pkgs.expect}/bin/expect -f
    set timeout 10
    spawn ${cfg.package}/bin/pretalx init

    expect "E-Mail: "
    send -- "${cfg.init.admin.email}\n"

    set password [string trim [read [open "${cfg.init.admin.passwordFile}"]]]

    expect {
    "Password: " { send -- "$password\n" }
    "Error: That E-Mail is already taken." { puts "pretalx appears to be already initialized"; exit 0 }
    }

    expect "Password (again): "
    send -- "$password\n"

    expect {
    -ex {Bypass password validation and create user anyway? [y/N]: } { puts "password is too weak"; exit 1 }
    -ex {Name (e.g. "The Conference Organiser"): } { send -- "${cfg.init.organiser.name}\n" }
    }

    expect -ex {Slug (e.g. "conforg", used in urls): }
    send -- "${cfg.init.organiser.slug}\n"

    expect eof
  '';

  environmentFile =
    pkgs.runCommand "pretalx-environ" {
      buildInputs = [cfg.package gunicorn]; # Sets PYTHONPATH in derivation
    } ''
      cat > $out <<EOF
      PYTHONPATH=$PYTHONPATH
      EOF
    '';
in {
  options.services.pretalx = with types; {
    enable = mkEnableOption "Enable pretalx server.";

    package = mkPackageOption ngipkgs "pretalx" {};

    bind = mkOption {
      type = str;
      description = "IP address or hostname that pretalx binds to.";
      default = "127.0.0.1";
      example = "0.0.0.0";
    };

    port = mkOption {
      type = int;
      description = "TCP port that the pretalx HTTP server binds to.";
      default = 8000;
    };

    user = mkOption {
      type = str;
      description = "Username of the system user that should own files and services related to pretalx.";
      default = "pretalx";
    };

    group = mkOption {
      type = str;
      description = "Group that contains the system user that executes pretalx.";
      default = "pretalx";
    };

    filesystem = {
      data = mkOption {
        type = path;
        description = ''
          Path that is the base for all other directories (see options `media`, `static`, `logs`). Unless you have a compelling reason to keep other files apart, setting this option is the easiest way to configure file storage.
        '';
        default = libDir + "/data";
      };

      media = mkOption {
        type = str;
        description = ''
          Directory that contains user generated files. It needs to be writable by the pretalx process.
        '';
        default = "${cfg.filesystem.data}/media";
      };

      logs = mkOption {
        type = str;
        description = ''
          Directory that contains logged data. It needs to be writable by the pretalx process.
        '';
        default = "${cfg.filesystem.data}/logs";
      };

      static = mkOption {
        type = str;
        description = ''
          Directory that contains static files. It needs to be writable by the pretalx process. pretalx will put files there.
        '';
        default = "${cfg.filesystem.data}/static";
      };
    };

    site = let
      cspOption = mkOption {
        type = nullOr str;
        description = ''
          Use this setting to update the CSP security headers.
          See <https://docs.pretalx.org/administrator/configure.html#csp-csp-script-csp-style-csp-img-csp-form>.
        '';
        default = null;
        example = "https://example.com,'self'";
      };
    in {
      url = mkOption {
        type = str;
        description = ''
          URL for pretalx. pretalx uses this value when it has to render full URLs, for example in emails or feeds. It is also used to determine the allowed incoming hosts.
        '';
        default = "http://localhost:${builtins.toString cfg.port}";
        example = "http://pretalx.example.com";
      };

      secretFile = mkOption {
        type = nullOr path;
        description = "Path to a file containing a secret key that the Django web framework uses for cryptographic signing. See <https://docs.pretalx.org/administrator/configure.html#secret>";
        default = null;
        example = "/run/secrets/pretalx/secret";
      };

      media = mkOption {
        type = str;
        description = "Path that is appended to the site URL to address media files (all files uploaded by users or generated by pretalx).";
        default = "/media/";
      };

      static = mkOption {
        type = str;
        description = "Path that is appended to the site URL to address static files.";
        default = "/static/";
      };

      csp = cspOption;
      csp_script = cspOption;
      csp_style = cspOption;
      csp_img = cspOption;
      csp_form = cspOption;
    };

    database = {
      backend = mkOption {
        type = enum ["postgresql" "mysql" "sqlite3"];
        description = ''
          The default is SQLite ("sqlite3"), which is not a production
          database. Please use a database like PostgreSQL ("postgresql") or MySQL ("mysql").
        '';
        default = "sqlite3";
      };

      name = mkOption {
        type = str;
        description = "Database name. If you use SQLite, this is the filesystem path to the database file.";
        default = "pretalx";
      };

      user = mkOption {
        type = nullOr str;
        default = null;
        example = "pretalx";
      };

      passwordFile = mkOption {
        type = nullOr path;
        description = "Path to a file containing the database password. If you use PostgreSQL, consider using its peer authentication and not setting a password.";
        default = null;
        example = "/run/secrets/pretalx/database";
      };

      host = mkOption {
        type = nullOr str;
        description = "Database host, or path to a socket (if you use PostgreSQL or MySQL). For local PostgreSQL authentication, you can leave this variable empty.";
        default = null;
        example = "localhost";
      };

      port = mkOption {
        type = nullOr int;
        description = "Database port (e.g. `5432` for PostgreSQL or `3306` for MySQL).";
        default = null;
        example = "5432";
      };
    };

    mail = {
      enable = mkOption {
        type = bool;
        description = "Enable sending e-mails from pretalx.";
        default = true;
      };

      from = mkOption {
        type = str;
        description = "Fall-back sender address, e.g. for when pretalx sends event-independent e-mails.";
        default = "admin@localhost";
      };

      host = mkOption {
        type = str;
        description = "Hostname of the SMTP server for sending e-mails.";
        default = "localhost";
      };

      port = mkOption {
        type = int;
        description = "TCP port of the SMTP server for sending e-mails.";
        default = 25;
      };

      user = mkOption {
        type = str;
        description = "Username for SMTP server authentication.";
        example = "admin";
      };

      passwordFile = mkOption {
        type = path;
        description = "Path to a file containing the password for SMTP server authentication.";
        example = "/run/secrets/pretalx/mail";
      };

      tls = mkOption {
        type = bool;
        description = "Whether to use TLS for sending mail.";
        default = false;
      };

      ssl = mkOption {
        type = bool;
        description = "Whether to use SSL for sending mail.";
        default = true;
      };
    };

    celery = {
      enable = mkEnableOption "Enable support for Celery.";

      backendFile = mkOption {
        type = nullOr path;
        description = "Path to a file that contains the location (connection URI) of Celery backend. If you use a standard Redis-based setup, the file should contain `redis://127.0.0.1/1` or similar. Check the documentation <https://docs.celeryq.dev/en/stable/getting-started/backends-and-brokers/redis.html>.";
        default = null;
        example = "/run/secrets/pretalx/celery-backend";
      };

      brokerFile = mkOption {
        type = nullOr path;
        description = "Path to a file that contains the location (connection URI) of Celery broker. If you use a standard Redis-based setup, the file should contain `redis://127.0.0.1/2` or similar. Check the documentation <https://docs.celeryq.dev/en/stable/getting-started/backends-and-brokers/redis.html>.";
        default = null;
        example = "/run/secrets/pretalx/celery-broker";
      };
    };

    redis = {
      enable = mkEnableOption "Enable support for Redis.";

      locationFile = mkOption {
        type = path;
        description = ''
          Path to a file that contains the location (connection URI) of Redis server, if you want to use it as a cache. Contents of the file: `redis://[:password]@127.0.0.1:6379/1` would be sensible, or `unix://[:password]@/path/to/socket.sock?db=0` if you prefer to use sockets.
        '';
        example = "/run/secrets/pretalx/redis";
      };

      session = mkOption {
        type = bool;
        description = "Whether to use Redis as session storage.";
        default = false;
      };
    };

    logging = {
      enable = mkEnableOption "Enable support for logging.";

      email = mkOption {
        type = str;
        description = "E-mail address (or comma-separated list of addresses) to send system logs to.";
        example = "root@example.com,admin@example.com";
      };

      email_level = mkOption {
        type = enum ["DEBUG" "INFO" "WARNING" "ERROR" "CRITICAL"];
        description = "Log level to start sending emails at.";
        default = "ERROR";
      };
    };

    locale = {
      language_code = mkOption {
        type = str;
        description = "Default locale.";
        default = "en";
      };
      time_zone = mkOption {
        type = str;
        description = ''
          Default time zone as a `pytz` name.

          You can use following code to generate the full list of timezone names:

          ```python
          import pytz

          print(pytz.all_timezones)
          ```
        '';
        default = "UTC";
      };
    };

    extraConfig = mkOption {
      type = lines;
      description = ''
        Extra lines of configuration to be appended to the generated pretalx configuration file.
        See <https://docs.pretalx.org/administrator/configure.html> for all options.
      '';
      default = "";
    };

    init = {
      admin = {
        email = mkOption {
          type = str;
          description = "E-mail address of the administrator.";
          example = "admin@example.com";
        };

        passwordFile = mkOption {
          type = path;
          description = "Path to a file containing the administrator password.";
          example = "/run/secrets/pretalx/admin";
        };
      };

      organiser = {
        name = mkOption {
          type = str;
          description = "Name of the conference organiser.";
          example = "The Conference Organiser";
        };

        slug = mkOption {
          type = str;
          description = "Slug of the conference organiser (to be used in URLs).";
          example = "conforg";
        };
      };
    };
  };

  config = mkIf cfg.enable {
    assertions = [
      {
        assertion = !(cfg.mail.tls && cfg.mail.ssl);
        message = "Enable either `services.pretalx.mail.tls` or `services.pretalx.mail.ssl`.";
      }
    ];

    users.users."${cfg.user}" = {
      isSystemUser = true;
      createHome = true;
      home = libDir;
      group = cfg.group;
    };

    users.groups."${cfg.group}" = {};

    environment.etc."pretalx/pretalx.cfg".text = let
      hiddenNames = ["enable" "passwordFile" "locationFile" "backendFile" "brokerFile" "secretFile"];
      ifEnable = s:
        if s.enable
        then s
        else {};
      pretalxCfg =
        filterAttrs (n: v:
          v != {}) # Removes empty attrsets, otherwise `generators.toINI` will fail.
        
        (filterAttrsRecursive (n: v: (!(elem n hiddenNames) && v != null)) {
          inherit (cfg) filesystem site database locale;

          celery = ifEnable cfg.celery;
          logging = ifEnable cfg.logging;
          mail = ifEnable cfg.mail;
          redis = ifEnable cfg.redis;
        });
    in ''
      ${generators.toINI {} pretalxCfg}
      ${cfg.extraConfig}
    '';

    systemd = {
      services = let
        catFile = varname: filename: "export ${varname}=\"$(cat ${filename})\"";
        exportPasswordEnv = lib.concatStringsSep "\n" ([]
          ++ optional cfg.mail.enable (catFile "PRETALX_MAIL_PASSWORD" cfg.mail.passwordFile)
          ++ optional (cfg.database.passwordFile != null) (catFile "PRETALX_DB_PASS" cfg.database.passwordFile)
          ++ optional cfg.redis.enable (catFile "PRETALX_REDIS" cfg.redis.locationFile)
          ++ optional (cfg.site.secretFile != null) (catFile "SECRET_KEY" cfg.site.secretFile)
          ++ optional cfg.celery.enable ''
            ${catFile "PRETALX_CELERY_BACKEND" cfg.celery.backendFile}
            ${catFile "PRETALX_CELERY_BROKER" cfg.celery.brokerFile}
          '');
        oneshotServiceConfig = {
          Type = "oneshot";
          EnvironmentFile = environmentFile;
          User = cfg.user;
          Group = cfg.group;
        };
        mkOneshot = command: {
          serviceConfig = oneshotServiceConfig;
          script = ''
            ${exportPasswordEnv}
            ${cfg.package}/bin/pretalx ${command}
          '';
        };
      in {
        pretalx-web = {
          serviceConfig = {
            Type = "notify";
            Restart = "on-failure";
            EnvironmentFile = environmentFile;
            User = cfg.user;
            Group = cfg.group;
            ExecStart = pkgs.writeScript "webserver" ''
              #!${pkgs.runtimeShell}
              set -euo pipefail

              ${exportPasswordEnv}

              ${cfg.package}/bin/pretalx collectstatic --noinput
              ${cfg.package}/bin/pretalx compress

              exec ${gunicorn}/bin/gunicorn pretalx.wsgi --name pretalx \
              --workers 3 \
              --log-level=info \
              --bind=${cfg.bind}:${toString cfg.port}
            '';
          };
          wantedBy = ["multi-user.target"];
          requires = ["pretalx-init.service"];
          after = ["pretalx-init.service"];
        };

        pretalx-init = {
          serviceConfig = oneshotServiceConfig;
          script = ''
            ${exportPasswordEnv}
            ${init}/bin/expect-pretalx-init
          '';
          requires = ["pretalx-migrate.service"];
          after = ["network.target" "pretalx-migrate.service"];
        };

        pretalx-migrate = mkOneshot "migrate";
        pretalx-rebuild = mkOneshot "rebuild";
        pretalx-clearsessions = mkOneshot "clearsessions";
        pretalx-runperiodic = mkOneshot "runperiodic";
      };

      timers = let
        mkTimer = {
          description,
          unit,
          onCalendar,
        }: {
          inherit description;
          requires = ["pretalx-migrate.service"];
          after = ["network.target"];
          wantedBy = ["timers.target"];
          timerConfig = {
            Persistent = true;
            OnCalendar = onCalendar;
            Unit = unit;
          };
        };
      in {
        # About once a month
        pretalx-clearsessions = mkTimer {
          description = "Clear pretalx sessions";
          unit = "pretalx-clearsessions.service";
          onCalendar = "monthly";
        };

        # Once every 5 minutes
        pretalx-runperiodic = mkTimer {
          description = "Run pretalx tasks";
          unit = "pretalx-runperiodic.service";
          onCalendar = "*:0/5";
        };
      };
    };
  };
}
